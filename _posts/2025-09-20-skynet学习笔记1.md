---
layout:     post
title:      "skynet学习笔记1"
date:       2025-09-20
author:     "suhiymof"
header-img: "img/post-bg-2015.jpg"
tags:
    - skynet
---

# lua服务注册流程
## 示例代码
```lua
local skynet = require "skynet"
local game = require "logic.game" 
skynet.start(function()
    skynet.error("main service start")

    skynet.newservice("debug_console",8000)
    
    local db = skynet.newservice("db")

    game.addbag()
    
    local key = "name"
    local value = "agang"
    
    data = skynet.call(db, "lua", "SET",key,value)
    skynet.error("oldname is: ",data )

    data = skynet.call(db, "lua", "GET",key)
    skynet.error("newname is: ",data )

    skynet.exit()
    
end)
```
### 举例db服务
```
local db = skynet.newservice("db")
```
- newservice会阻塞住，直到db服务注册完成
    ```
    return skynet.call(".launcher", "lua" , "LAUNCH", "snlua", name, ...)
    ```
- skynet.call将注册消息发送给launcher服务
```
    -- @".launcher": 发送给launcer服务
    -- @"lua" ：lua消息
    -- @"LAUNCH": 调用launcher.lua的command.LAUNCH
    -- @"snlua": snlua mod
    -- @name: 服务名,也就是db
    function skynet.call(addr, typename, ...)
        local tag = session_coroutine_tracetag[running_thread]
        if tag then
            c.trace(tag, "call", 2) --表示即将调用call
            c.send(addr, skynet.PTYPE_TRACE, 0, tag) -- 提前通知目标服务 做好跟踪的准备
        end

        local p = proto[typename]   -- typename: "lua"
        local session = c.send(addr, p.id , nil , p.pack(...))--seesion是通过当前服务分配的, p.pack(...)将"LAUNCH", "snlua", "lua"打包
        if session == nil then
            error("call to invalid address " .. skynet.address(addr))
        end
        return p.unpack(yield_call(addr, session))  -- yield住
    end
```
- launcher过程
    - 对lua消息的处理
    ```
        -- @address: main服务地址
        -- @cmd:  "LAUNCH"
        -- @...:  "snlua", "db"
        skynet.dispatch("lua", function(session, address, cmd , ...)
            cmd = string.upper(cmd)
            local f = command[cmd]  -- f就是command.LAUNCH
            if f then
                local ret = f(address, ...)
                if ret ~= NORET then
                    skynet.ret(skynet.pack(ret))
                end
            else
                skynet.ret(skynet.pack {"Unknown command"} )
            end
        end)
    ```
    - launch_service处理
    ```
        -- @service: "snlua"
        -- @...:    "db"
        local function launch_service(service, ...)
            local param = table.concat({...}, " ")      -- param: "db"
            local inst = skynet.launch(service, param) --inst是新建服务的数字地址
            local session = skynet.context()
            local response = skynet.response() --这个返回一个闭包， 这里会保存上下文环境,等服务都处理完成后会有用
            if inst then
                services[inst] = service .. " " .. param
                instance[inst] = response
                launch_session[inst] = session
            else
                response(false)
                return
            end
            return inst
        end
    ```
    - skynet.launch
    ```
        -- @...: "snlua", "db"
        function skynet.launch(...)
            local addr = c.command("LAUNCH", table.concat({...}," ")) --这里返回的地址是字符串,格式是 [冒号 + 8位16进制数] 例如 ":000123ff", ":"+ 服务的handle 
            if addr then
                return tonumber(string.sub(addr , 2), 16)--这里把开头的冒号去掉 ,把8位16进制数转变成lua表示的十进制数 
            end
        end
    ```
    - cmd_launch
    ```
        // @param: "snlua db"
        static const char *
        cmd_launch(struct skynet_context * context, const char * param) {
            size_t sz = strlen(param);
            char tmp[sz+1];
            strcpy(tmp,param);
            char * args = tmp;
            char * mod = strsep(&args, " \t\r\n");  // mod就是snlua
            args = strsep(&args, "\r\n");   // args就是db
            struct skynet_context * inst = skynet_context_new(mod,args);
            if (inst == NULL) {
                return NULL;
            } else {
                id_to_hex(context->result, inst->handle);//把handle表示成8位16进制的字符串 注意是以冒号开头 举例 ":000123ff"
                return context->result;
            }
        }
    ```
    - snlua模块初始化 snlua_init,给自己发第一个消息
    ```
        // @args： 对DB服务来说就是"db"
        int
        snlua_init(struct snlua *l, struct skynet_context *ctx, const char * args) {//args就是 "launcher"
            int sz = strlen(args);
            char * tmp = skynet_malloc(sz);//分配一个内存块 
            memcpy(tmp, args, sz);
            skynet_callback(ctx, l , launch_cb);//收到第一个消息后 就会执行launch_cb
            const char * self = skynet_command(ctx, "REG", NULL);   // 返回: ":" + handle
            uint32_t handle_id = strtoul(self+1, NULL, 16);//将字符串转换成unsigned long(无符号长整型数)
            // it must be first message
            skynet_send(ctx, 0, handle_id, PTYPE_TAG_DONTCOPY,0, tmp, sz);//倒数第三个参数为0 表示 session
            return 0;
        }
    ```
    - 第一个消息的处理 launch_cb -> init_cb
        - launch_cb
        ```
            // @msg: "db"
            static int
            launch_cb(struct skynet_context * context, void *ud, int type, int session, uint32_t source , const void * msg, size_t sz) {
                assert(type == 0 && session == 0);
                struct snlua *l = ud;
                skynet_callback(context, NULL, NULL);//这里取消了回调函数 但是最终lua服务的回调函数的设置 是通过lua服务的skynet.start()函数 
                int err = init_cb(l, context, msg, sz);
                if (err) {
                    skynet_command(context, "EXIT", NULL);
                }

                return 0;
            }
        ```
        - init_cb
            - lua_pushlstring(L, args, sz);会使用loader.lua加载args对应的lua文件，也就是db.lua
            - r = lua_pcall(L,1,0,1);开始执行db.lua
        ```
            // @args: "db"
            static int
            init_cb(struct snlua *l, struct skynet_context *ctx, const char * args, size_t sz) {
                lua_State *L = l->L;
                l->ctx = ctx;
                lua_gc(L, LUA_GCSTOP, 0);
                lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
                lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
                luaL_openlibs(L);
                luaL_requiref(L, "skynet.profile", init_profile, 0);//当你在lua层require "skynet.profile" 的时候会调用c函数 init_profile ,最终返回一张表

                int profile_lib = lua_gettop(L); //这里做了修改主要是为了获取协程运行的时间
                // replace coroutine.resume / coroutine.wrap
                lua_getglobal(L, "coroutine");
                lua_getfield(L, profile_lib, "resume");
                lua_setfield(L, -2, "resume");
                lua_getfield(L, profile_lib, "wrap");
                lua_setfield(L, -2, "wrap");

                lua_settop(L, profile_lib-1);

                lua_pushlightuserdata(L, ctx);
                lua_setfield(L, LUA_REGISTRYINDEX, "skynet_context");//把ctx设置到当前服务对应的 lua_State 的全局注册表中 key的名字是 "skynet_context"
                luaL_requiref(L, "skynet.codecache", codecache , 0);//当你在lua层require "skynet.codecache" 的时候会调用c函数 codecache ,最终返回一张表
                lua_pop(L,1);

                lua_gc(L, LUA_GCGEN, 0, 0);

                const char *path = optstring(ctx, "lua_path","./lualib/?.lua;./lualib/?/init.lua");//启动skynet的配置文件中配置项 是小写字符串 比如 lua_path
                lua_pushstring(L, path);
                lua_setglobal(L, "LUA_PATH");//最后设置到lua虚拟机中的是 大写字母 LUA_PATH
                const char *cpath = optstring(ctx, "lua_cpath","./luaclib/?.so");
                lua_pushstring(L, cpath);
                lua_setglobal(L, "LUA_CPATH");
                const char *service = optstring(ctx, "luaservice", "./service/?.lua");
                lua_pushstring(L, service);
                lua_setglobal(L, "LUA_SERVICE");
                const char *preload = skynet_command(ctx, "GETENV", "preload");
                lua_pushstring(L, preload);
                lua_setglobal(L, "LUA_PRELOAD");

                lua_pushcfunction(L, traceback);
                assert(lua_gettop(L) == 1);

                const char * loader = optstring(ctx, "lualoader", "./lualib/loader.lua");//我们真正的lua服务文件是被loader.lua文件加载执行的

                int r = luaL_loadfile(L,loader);//把lua文件加载编译成一个匿名函数 f
                if (r != LUA_OK) {
                    skynet_error(ctx, "Can't load %s : %s", loader, lua_tostring(L, -1));
                    report_launcher_error(ctx);
                    return 1;
                }
                lua_pushlstring(L, args, sz);
                r = lua_pcall(L,1,0,1);//开始执行lua文件了 ,即开始执行匿名函数 f(args)
                if (r != LUA_OK) {
                    skynet_error(ctx, "lua loader error : %s", lua_tostring(L, -1));
                    report_launcher_error(ctx);
                    return 1;
                }
                lua_settop(L,0);
                if (lua_getfield(L, LUA_REGISTRYINDEX, "memlimit") == LUA_TNUMBER) {//这个值是在上面lua文件执行时调用skynet.memlimit设置的
                    size_t limit = lua_tointeger(L, -1);
                    l->mem_limit = limit;
                    skynet_error(ctx, "Set memory limit to %.2f M", (float)limit / (1024 * 1024));
                    lua_pushnil(L);
                    lua_setfield(L, LUA_REGISTRYINDEX, "memlimit");
                }
                lua_pop(L, 1);

                lua_gc(L, LUA_GCRESTART, 0);

                return 0;
            }
        ```
        - db.lua对应的代码
        ```
            local skynet = require "skynet"
            local db = {}

            local command = {}

            function command.GET(key)
                return db[key]
            end

            function command.SET(key, value)
                local last = db[key]
                db[key] = value
                return last
            end

            skynet.start(function()
                
                skynet.dispatch("lua", function(session, address, cmd, ...)
                    
                    local f = command[cmd]
                    if f then
                        skynet.ret(skynet.pack(f(...)))
                    end
                end)

            end)
        ```
    - db服务文件在调用完skynet.start会发送LAUNCHOK 消息给 launcher服务
        ```
        function skynet.init_service(start)
            local function main()
                skynet_require.init_all()
                start()
            end
            local ok, err = xpcall(main, traceback)
            if not ok then
                skynet.error("init service failed: " .. tostring(err))
                skynet.send(".launcher","lua", "ERROR")
                skynet.exit()
            else
                skynet.send(".launcher","lua", "LAUNCHOK")--任何服务在完成start后 都会发送LAUNCHOK 消息给 launcher服务
            end
        end

        function skynet.start(start_func)
            c.callback(skynet.dispatch_message)
            init_thread = skynet.timeout(0, function()
                skynet.init_service(start_func)
                init_thread = nil
            end)
        end
        ```
    - launcher服务收到LAUNCHOK后就会给main服务发送response，这样local db = skynet.newservice("db")就会resume继续执行了
    ```
        --每一个lua服务启动完成后(即f函数执行完毕，f指的是skynet.start(f)里的f)，都会发送一个LAUNCHOK 消息给 launcher服务
        function command.LAUNCHOK(address) --收到服务b send过来的消息 表示服务b自身已经完成执行skynet.start注册的函数f
            -- init notice
            local response = instance[address]
            if response then
                response(true, address) -- 发送响应给 之前的 a服务
                instance[address] = nil
                launch_session[address] = nil
            end

            return NORET
        end
    ```