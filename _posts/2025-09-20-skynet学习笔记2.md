---
layout:     post
title:      "skynet学习笔记2"
date:       2025-09-20
author:     "suhiymof"
header-img: "img/post-bg-2015.jpg"
tags:
    - skynet
---

- 1. bootstrap服务创建，push一个消息到bootstrap服务的消息队列

- 2. 启动工作线程

- 3. 工作线程遍历消息队列获取到上面发送的消息。执行回调函数 launch_cb， 清空bootstrap服务对应消息的回调函数

- 4. 将bootstrap.lua加载编译成一个匿名函数并执行

- 5. 执行skynet.start

    - 5.1 将bootstrap服务回调函数设置为 skynet.dispatch_message

    - 5.2 执行 skynet.timeout

    - 5.3 调用c 定时器函数发送一个 PTYPE_RESPONSE 消息给当前服务, 用来后续唤醒下一步创建的协程

    - 5.4 创建一个协程, 这个协程对应的唤醒调用函数会调用 skynet.init_service 

    - 5.5 skynet.init_service 会调用 skynet.start 的参数，也就是入口函数

    - 5.6 bootstrap的最后会调用skynet.exit()
    
        - 5.6.1 会给launcher发送一个REMOVE，但是bootstrap是在底层直接创建的，所以launcher里面查不到bootstrap服务，也就没有什么处理了

        - 5.6.2 最后会调用 coroutine_yield "QUIT" 挂起协程，就没有机会发送"LAUNCHOK"

    - 5.7 一般通过skynet.newservice创建的服务在唤醒调用入口函数以后会发送"LAUNCHOK"给launcer服务

- 6. 继续入口函数

    - 6.1 skynet.launch 创建 launcher 服务， 不阻塞当前协程

    - 6.2 launch.lua里面会设置lua类型消息的dispatch函数

        ```
        skynet.dispatch("lua", function(session, address, cmd , ...)
            cmd = string.upper(cmd)
            local f = command[cmd]
            if f then
                local ret = f(address, ...)
                if ret ~= NORET then
                    skynet.ret(skynet.pack(ret))
                end
            else
                skynet.ret(skynet.pack {"Unknown command"} )
            end
        end)
        ```

    - 6.3 调用skynet.newservice创建各种服务，每次调用的时候都会阻塞当前协程。

        - 6.3.1 调用skynet.call(".launcher", "lua" , "LAUNCH", "snlua", name, ...) 给launch服务发送消息。这时候launch服务还没处理完第一条消息，也就是加载launcher.lua,并执行里面的内容

        - 6.3.2 所以这时候当前协程是阻塞的，当launch服务处理了上面这条消息(也就是执行launcher.lua里面的command.LAUNCH), 就会调用skynet.launch创建对应的服务

        - 6.3.3 调用新服务对应的skynet.start

            - 6.3.3.1 将服务回调函数设置为 skynet.dispatch_message

            - 6.3.3.2 执行 skynet.timeout

            - 6.3.3.3 调用c 定时器函数发送一个 PTYPE_RESPONSE 消息给新服务, 用来后续唤醒下一步创建的协程

            - 6.3.3.4 创建一个协程, 这个协程对应的唤醒调用函数会调用 skynet.init_service 

            - 6.3.3.5 skynet.init_service 会调用 skynet.start 的参数，也就是入口函数

            - 6.3.3.6 入口函数执行完且正常，发送"LAUNCHOK"给launcer服务

            - 6.3.3.7 launch服务收到"LAUNCHOK"以后, 调用 6.3.2 保存的response闭包，之后就会唤醒 6.3.2 阻塞的协程，这样这个服务就创建完成了

- 7. 最后创建main服务 pcall(skynet.newservice,skynet.getenv "start" or "main") 
